{"version":3,"sources":["webpack:///ml-fft/webpack/universalModuleDefinition","webpack:///ml-fft/ml-fft.min.js","webpack:///ml-fft/webpack/bootstrap 9b80e1425f8a39623bf1","webpack:///ml-fft/./src/index.js","webpack:///ml-fft/./src/FFTUtils.js","webpack:///ml-fft/./src/fftlib.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","FFTUtils","FFT","DEBUG","ifft2DArray","ft","ftRows","ftCols","tempTransform","Array","nRows","nCols","init","tmpCols","re","im","iCol","iRow","bt","finalTransform","tmpRows","scale","indexB","fft2DArray","data","opt","Object","assign","inplace","index","iRow0","iRow1","iRow2","iRow3","row1","row2","slice","fft1d","reconstructTwoRealFFT","k","isNaN","fourierTransform","realTransform1","realTransform2","length","rm","rp","ip","j","i","convolute2DI","ftSignal","ftFilter","convolute","kernel","ftSpectrum","dimR","dimC","ftFilterData","shiftR","Math","floor","shiftC","ir","ic","toRadix2","irow","icol","cols","rows","prows","pcols","output","crop","destinyRow","sourceRow","version","release","date","toString","_n","_bitrev","_cstb","core","n","Error","_initArray","_makeBitReversalTable","_makeCosSinTable","fft","ifft1d","bt1d","fft2d","tre","tim","y","x1","x2","x","y1","y2","ifft2d","inv","d","h","ik","tmp","wr","wi","xr","xi","n4","l","Uint32Array","Float64Array","_paddingZero","n2","n8","n2p4","t","sin","PI","dc","ds","sqrt","s","apis","ifft"],"mappings":"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","file":"ml-fft.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mlFft\"] = factory();\n\telse\n\t\troot[\"mlFft\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mlFft\"] = factory();\n\telse\n\t\troot[\"mlFft\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.FFTUtils = __webpack_require__(1);\n\texports.FFT = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict'\n\t\n\tvar FFT = __webpack_require__(2);\n\t\n\tvar FFTUtils= {\n\t    DEBUG : false,\n\t\n\t    /**\n\t     * Calculates the inverse of a 2D Fourier transform\n\t     *\n\t     * @param ft\n\t     * @param ftRows\n\t     * @param ftCols\n\t     * @return\n\t     */\n\t    ifft2DArray : function(ft, ftRows, ftCols){\n\t        var tempTransform = new Array(ftRows * ftCols);\n\t        var nRows = ftRows / 2;\n\t        var nCols = (ftCols - 1) * 2;\n\t        // reverse transform columns\n\t        FFT.init(nRows);\n\t        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n\t        for (var iCol = 0; iCol < ftCols; iCol++) {\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                tmpCols.re[iRow] = ft[(iRow * 2) * ftCols + iCol];\n\t                tmpCols.im[iRow] = ft[(iRow * 2 + 1) * ftCols + iCol];\n\t            }\n\t            //Unnormalized inverse transform\n\t            FFT.bt(tmpCols.re, tmpCols.im);\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                tempTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n\t                tempTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n\t            }\n\t        }\n\t\n\t        // reverse row transform\n\t        var finalTransform = new Array(nRows * nCols);\n\t        FFT.init(nCols);\n\t        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n\t        var scale = nCols * nRows;\n\t        for (var iRow = 0; iRow < ftRows; iRow += 2) {\n\t            tmpRows.re[0] = tempTransform[iRow * ftCols];\n\t            tmpRows.im[0] = tempTransform[(iRow + 1) * ftCols];\n\t            for (var iCol = 1; iCol < ftCols; iCol++) {\n\t                tmpRows.re[iCol] = tempTransform[iRow * ftCols + iCol];\n\t                tmpRows.im[iCol] = tempTransform[(iRow + 1) * ftCols + iCol];\n\t                tmpRows.re[nCols - iCol] = tempTransform[iRow * ftCols + iCol];\n\t                tmpRows.im[nCols - iCol] = -tempTransform[(iRow + 1) * ftCols + iCol];\n\t            }\n\t            //Unnormalized inverse transform\n\t            FFT.bt(tmpRows.re, tmpRows.im);\n\t\n\t            var indexB = (iRow / 2) * nCols;\n\t            for (var iCol = nCols - 1; iCol >= 0; iCol--) {\n\t                finalTransform[indexB + iCol] = tmpRows.re[iCol] / scale;\n\t            }\n\t        }\n\t        return finalTransform;\n\t    },\n\t    /**\n\t     * Calculates the fourier transform of a matrix of size (nRows,nCols) It is\n\t     * assumed that both nRows and nCols are a power of two\n\t     *\n\t     * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the\n\t     * even rows contain the real part and the odd rows the imaginary part of the\n\t     * transform\n\t     * @param data\n\t     * @param nRows\n\t     * @param nCols\n\t     * @return\n\t     */\n\t    fft2DArray:function(data, nRows, nCols, opt) {\n\t        var options = Object.assign({},{inplace:true})\n\t        var ftCols = (nCols / 2 + 1);\n\t        var ftRows = nRows * 2;\n\t        var tempTransform = new Array(ftRows * ftCols);\n\t        FFT.init(nCols);\n\t        // transform rows\n\t        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n\t        var row1 = {re: new Array(nCols), im: new Array(nCols)}\n\t        var row2 = {re: new Array(nCols), im: new Array(nCols)}\n\t        var index, iRow0, iRow1, iRow2, iRow3;\n\t        for (var iRow = 0; iRow < nRows / 2; iRow++) {\n\t            index = (iRow * 2) * nCols;\n\t            tmpRows.re = data.slice(index, index + nCols);\n\t\n\t            index = (iRow * 2 + 1) * nCols;\n\t            tmpRows.im = data.slice(index, index + nCols);\n\t\n\t            FFT.fft1d(tmpRows.re, tmpRows.im);\n\t\n\t            this.reconstructTwoRealFFT(tmpRows, row1, row2);\n\t            //Now lets put back the result into the output array\n\t            iRow0 = (iRow * 4) * ftCols;\n\t            iRow1 = (iRow * 4 + 1) * ftCols;\n\t            iRow2 = (iRow * 4 + 2) * ftCols;\n\t            iRow3 = (iRow * 4 + 3) * ftCols;\n\t            for (var k = ftCols - 1; k >= 0; k--) {\n\t                tempTransform[iRow0 + k] = row1.re[k];\n\t                tempTransform[iRow1 + k] = row1.im[k];\n\t                tempTransform[iRow2 + k] = row2.re[k];\n\t                tempTransform[iRow3 + k] = row2.im[k];\n\t            }\n\t        }\n\t\n\t        //console.log(tempTransform);\n\t        row1 = null;\n\t        row2 = null;\n\t        // transform columns\n\t        var finalTransform = new Array(ftRows * ftCols);\n\t\n\t        FFT.init(nRows);\n\t        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n\t        for (var iCol = ftCols - 1; iCol >= 0; iCol--) {\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                tmpCols.re[iRow] = tempTransform[(iRow * 2) * ftCols + iCol];\n\t                tmpCols.im[iRow] = tempTransform[(iRow * 2 + 1) * ftCols + iCol];\n\t                //TODO Chech why this happens\n\t                if(isNaN(tmpCols.re[iRow])){\n\t                    tmpCols.re[iRow]=0;\n\t                }\n\t                if(isNaN(tmpCols.im[iRow])){\n\t                    tmpCols.im[iRow]=0;\n\t                }\n\t            }\n\t            FFT.fft1d(tmpCols.re, tmpCols.im);\n\t            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n\t                finalTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n\t                finalTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n\t            }\n\t        }\n\t\n\t        //console.log(finalTransform);\n\t        return finalTransform;\n\t\n\t    },\n\t    /**\n\t     *\n\t     * @param fourierTransform\n\t     * @param realTransform1\n\t     * @param realTransform2\n\t     *\n\t     * Reconstructs the individual Fourier transforms of two simultaneously\n\t     * transformed series. Based on the Symmetry relationships (the asterisk\n\t     * denotes the complex conjugate)\n\t     *\n\t     * F_{N-n} = F_n^{*} for a purely real f transformed to F\n\t     *\n\t     * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G\n\t     *\n\t     */\n\t    reconstructTwoRealFFT:function(fourierTransform, realTransform1, realTransform2) {\n\t        var length = fourierTransform.re.length;\n\t\n\t        // the components n=0 are trivial\n\t        realTransform1.re[0] = fourierTransform.re[0];\n\t        realTransform1.im[0] = 0.0;\n\t        realTransform2.re[0] = fourierTransform.im[0];\n\t        realTransform2.im[0] = 0.0;\n\t        var rm, rp, im, ip, j;\n\t        for (var i = length / 2; i > 0; i--) {\n\t            j = length - i;\n\t            rm = 0.5 * (fourierTransform.re[i] - fourierTransform.re[j]);\n\t            rp = 0.5 * (fourierTransform.re[i] + fourierTransform.re[j]);\n\t            im = 0.5 * (fourierTransform.im[i] - fourierTransform.im[j]);\n\t            ip = 0.5 * (fourierTransform.im[i] + fourierTransform.im[j]);\n\t            realTransform1.re[i] = rp;\n\t            realTransform1.im[i] = im;\n\t            realTransform1.re[j] = rp;\n\t            realTransform1.im[j] = -im;\n\t            realTransform2.re[i] = ip;\n\t            realTransform2.im[i] = -rm;\n\t            realTransform2.re[j] = ip;\n\t            realTransform2.im[j] = rm;\n\t        }\n\t    },\n\t\n\t    /**\n\t     * In place version of convolute 2D\n\t     *\n\t     * @param ftSignal\n\t     * @param ftFilter\n\t     * @param ftRows\n\t     * @param ftCols\n\t     * @return\n\t     */\n\t    convolute2DI:function(ftSignal, ftFilter, ftRows, ftCols) {\n\t        var re, im;\n\t        for (var iRow = 0; iRow < ftRows / 2; iRow++) {\n\t            for (var iCol = 0; iCol < ftCols; iCol++) {\n\t                //\n\t                re = ftSignal[(iRow * 2) * ftCols + iCol]\n\t                    * ftFilter[(iRow * 2) * ftCols + iCol]\n\t                    - ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n\t                    * ftFilter[(iRow * 2 + 1) * ftCols + iCol];\n\t                im = ftSignal[(iRow * 2) * ftCols + iCol]\n\t                    * ftFilter[(iRow * 2 + 1) * ftCols + iCol]\n\t                    + ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n\t                    * ftFilter[(iRow * 2) * ftCols + iCol];\n\t                //\n\t                ftSignal[(iRow * 2) * ftCols + iCol] = re;\n\t                ftSignal[(iRow * 2 + 1) * ftCols + iCol] = im;\n\t            }\n\t        }\n\t    },\n\t    /**\n\t     *\n\t     * @param data\n\t     * @param kernel\n\t     * @param nRows\n\t     * @param nCols\n\t     * @returns {*}\n\t     */\n\t    convolute:function(data, kernel, nRows, nCols, opt) {\n\t        var ftSpectrum = new Array(nCols * nRows);\n\t        for (var i = 0; i<nRows * nCols; i++) {\n\t            ftSpectrum[i] = data[i];\n\t        }\n\t\n\t        ftSpectrum = this.fft2DArray(ftSpectrum, nRows, nCols);\n\t\n\t\n\t        var dimR = kernel.length;\n\t        var dimC = kernel[0].length;\n\t        var ftFilterData = new Array(nCols * nRows);\n\t        for(var i = 0; i < nCols * nRows; i++) {\n\t            ftFilterData[i] = 0;\n\t        }\n\t\n\t        var iRow, iCol;\n\t        var shiftR = Math.floor((dimR - 1) / 2);\n\t        var shiftC = Math.floor((dimC - 1) / 2);\n\t        for (var ir = 0; ir < dimR; ir++) {\n\t            iRow = (ir - shiftR + nRows) % nRows;\n\t            for (var ic = 0; ic < dimC; ic++) {\n\t                iCol = (ic - shiftC + nCols) % nCols;\n\t                ftFilterData[iRow * nCols + iCol] = kernel[ir][ic];\n\t            }\n\t        }\n\t        ftFilterData = this.fft2DArray(ftFilterData, nRows, nCols);\n\t\n\t        var ftRows = nRows * 2;\n\t        var ftCols = nCols / 2 + 1;\n\t        this.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);\n\t\n\t        return this.ifft2DArray(ftSpectrum, ftRows, ftCols);\n\t    },\n\t\n\t\n\t    toRadix2:function(data, nRows, nCols) {\n\t        var i, j, irow, icol;\n\t        var cols = nCols, rows = nRows, prows=0, pcols=0;\n\t        if(!(nCols !== 0 && (nCols & (nCols - 1)) === 0)) {\n\t            //Then we have to make a pading to next radix2\n\t            cols = 0;\n\t            while((nCols>>++cols)!=0);\n\t            cols=1<<cols;\n\t            pcols = cols-nCols;\n\t        }\n\t        if(!(nRows !== 0 && (nRows & (nRows - 1)) === 0)) {\n\t            //Then we have to make a pading to next radix2\n\t            rows = 0;\n\t            while((nRows>>++rows)!=0);\n\t            rows=1<<rows;\n\t            prows = (rows-nRows)*cols;\n\t        }\n\t        if(rows==nRows&&cols==nCols)//Do nothing. Returns the same input!!! Be careful\n\t            return {data:data, rows:nRows, cols:nCols};\n\t\n\t        var output = new Array(rows*cols);\n\t        var shiftR = Math.floor((rows-nRows)/2)-nRows;\n\t        var shiftC = Math.floor((cols-nCols)/2)-nCols;\n\t\n\t        for( i = 0; i < rows; i++) {\n\t            irow = i*cols;\n\t            icol = ((i-shiftR) % nRows) * nCols;\n\t            for( j = 0; j < cols; j++) {\n\t                output[irow+j] = data[(icol+(j-shiftC) % nCols) ];\n\t            }\n\t        }\n\t        return {data:output, rows:rows, cols:cols};\n\t    },\n\t\n\t    /**\n\t     * Crop the given matrix to fit the corresponding number of rows and columns\n\t     */\n\t    crop:function(data, rows, cols, nRows, nCols, opt) {\n\t\n\t        if(rows == nRows && cols == nCols)//Do nothing. Returns the same input!!! Be careful\n\t            return data;\n\t\n\t        var options = Object.assign({}, opt);\n\t\n\t        var output = new Array(nCols*nRows);\n\t\n\t        var shiftR = Math.floor((rows-nRows)/2);\n\t        var shiftC = Math.floor((cols-nCols)/2);\n\t        var destinyRow, sourceRow, i, j;\n\t        for( i = 0; i < nRows; i++) {\n\t            destinyRow = i*nCols;\n\t            sourceRow = (i+shiftR)*cols;\n\t            for( j = 0;j < nCols; j++) {\n\t                output[destinyRow+j] = data[sourceRow+(j+shiftC)];\n\t            }\n\t        }\n\t\n\t        return output;\n\t    }\n\t}\n\t\n\tmodule.exports = FFTUtils;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Fast Fourier Transform module\n\t * 1D-FFT/IFFT, 2D-FFT/IFFT (radix-2)\n\t */\n\tvar FFT = (function(){\n\t  var FFT;  \n\t  \n\t  if(true) {\n\t    FFT = exports;   // for CommonJS\n\t  } else {\n\t    FFT = {};\n\t  }\n\t  \n\t  var version = {\n\t    release: '0.3.0',\n\t    date: '2013-03'\n\t  };\n\t  FFT.toString = function() {\n\t    return \"version \" + version.release + \", released \" + version.date;\n\t  };\n\t\n\t  // core operations\n\t  var _n = 0,          // order\n\t      _bitrev = null,  // bit reversal table\n\t      _cstb = null;    // sin/cos table\n\t\n\t  var core = {\n\t    init : function(n) {\n\t      if(n !== 0 && (n & (n - 1)) === 0) {\n\t        _n = n;\n\t        core._initArray();\n\t        core._makeBitReversalTable();\n\t        core._makeCosSinTable();\n\t      } else {\n\t        throw new Error(\"init: radix-2 required\");\n\t      }\n\t    },\n\t    // 1D-FFT\n\t    fft1d : function(re, im) {\n\t      core.fft(re, im, 1);\n\t    },\n\t    // 1D-IFFT\n\t    ifft1d : function(re, im) {\n\t      var n = 1/_n;\n\t      core.fft(re, im, -1);\n\t      for(var i=0; i<_n; i++) {\n\t        re[i] *= n;\n\t        im[i] *= n;\n\t      }\n\t    },\n\t     // 1D-IFFT\n\t    bt1d : function(re, im) {\n\t      core.fft(re, im, -1);\n\t    },\n\t    // 2D-FFT Not very useful if the number of rows have to be equal to cols\n\t    fft2d : function(re, im) {\n\t      var tre = [],\n\t          tim = [],\n\t          i = 0;\n\t      // x-axis\n\t      for(var y=0; y<_n; y++) {\n\t        i = y*_n;\n\t        for(var x1=0; x1<_n; x1++) {\n\t          tre[x1] = re[x1 + i];\n\t          tim[x1] = im[x1 + i];\n\t        }\n\t        core.fft1d(tre, tim);\n\t        for(var x2=0; x2<_n; x2++) {\n\t          re[x2 + i] = tre[x2];\n\t          im[x2 + i] = tim[x2];\n\t        }\n\t      }\n\t      // y-axis\n\t      for(var x=0; x<_n; x++) {\n\t        for(var y1=0; y1<_n; y1++) {\n\t          i = x + y1*_n;\n\t          tre[y1] = re[i];\n\t          tim[y1] = im[i];\n\t        }\n\t        core.fft1d(tre, tim);\n\t        for(var y2=0; y2<_n; y2++) {\n\t          i = x + y2*_n;\n\t          re[i] = tre[y2];\n\t          im[i] = tim[y2];\n\t        }\n\t      }\n\t    },\n\t    // 2D-IFFT\n\t    ifft2d : function(re, im) {\n\t      var tre = [],\n\t          tim = [],\n\t          i = 0;\n\t      // x-axis\n\t      for(var y=0; y<_n; y++) {\n\t        i = y*_n;\n\t        for(var x1=0; x1<_n; x1++) {\n\t          tre[x1] = re[x1 + i];\n\t          tim[x1] = im[x1 + i];\n\t        }\n\t        core.ifft1d(tre, tim);\n\t        for(var x2=0; x2<_n; x2++) {\n\t          re[x2 + i] = tre[x2];\n\t          im[x2 + i] = tim[x2];\n\t        }\n\t      }\n\t      // y-axis\n\t      for(var x=0; x<_n; x++) {\n\t        for(var y1=0; y1<_n; y1++) {\n\t          i = x + y1*_n;\n\t          tre[y1] = re[i];\n\t          tim[y1] = im[i];\n\t        }\n\t        core.ifft1d(tre, tim);\n\t        for(var y2=0; y2<_n; y2++) {\n\t          i = x + y2*_n;\n\t          re[i] = tre[y2];\n\t          im[i] = tim[y2];\n\t        }\n\t      }\n\t    },\n\t    // core operation of FFT\n\t    fft : function(re, im, inv) {\n\t      var d, h, ik, m, tmp, wr, wi, xr, xi,\n\t          n4 = _n >> 2;\n\t      // bit reversal\n\t      for(var l=0; l<_n; l++) {\n\t        m = _bitrev[l];\n\t        if(l < m) {\n\t          tmp = re[l];\n\t          re[l] = re[m];\n\t          re[m] = tmp;\n\t          tmp = im[l];\n\t          im[l] = im[m];\n\t          im[m] = tmp;\n\t        }\n\t      }\n\t      // butterfly operation\n\t      for(var k=1; k<_n; k<<=1) {\n\t        h = 0;\n\t        d = _n/(k << 1);\n\t        for(var j=0; j<k; j++) {\n\t          wr = _cstb[h + n4];\n\t          wi = inv*_cstb[h];\n\t          for(var i=j; i<_n; i+=(k<<1)) {\n\t            ik = i + k;\n\t            xr = wr*re[ik] + wi*im[ik];\n\t            xi = wr*im[ik] - wi*re[ik];\n\t            re[ik] = re[i] - xr;\n\t            re[i] += xr;\n\t            im[ik] = im[i] - xi;\n\t            im[i] += xi;\n\t          }\n\t          h += d;\n\t        }\n\t      }\n\t    },\n\t    // initialize the array (supports TypedArray)\n\t    _initArray : function() {\n\t      if(typeof Uint32Array !== 'undefined') {\n\t        _bitrev = new Uint32Array(_n);\n\t      } else {\n\t        _bitrev = [];\n\t      }\n\t      if(typeof Float64Array !== 'undefined') {\n\t        _cstb = new Float64Array(_n*1.25);\n\t      } else {\n\t        _cstb = [];\n\t      }\n\t    },\n\t    // zero padding\n\t    _paddingZero : function() {\n\t      // TODO\n\t    },\n\t    // makes bit reversal table\n\t    _makeBitReversalTable : function() {\n\t      var i = 0,\n\t          j = 0,\n\t          k = 0;\n\t      _bitrev[0] = 0;\n\t      while(++i < _n) {\n\t        k = _n >> 1;\n\t        while(k <= j) {\n\t          j -= k;\n\t          k >>= 1;\n\t        }\n\t        j += k;\n\t        _bitrev[i] = j;\n\t      }\n\t    },\n\t    // makes trigonometiric function table\n\t    _makeCosSinTable : function() {\n\t      var n2 = _n >> 1,\n\t          n4 = _n >> 2,\n\t          n8 = _n >> 3,\n\t          n2p4 = n2 + n4,\n\t          t = Math.sin(Math.PI/_n),\n\t          dc = 2*t*t,\n\t          ds = Math.sqrt(dc*(2 - dc)),\n\t          c = _cstb[n4] = 1,\n\t          s = _cstb[0] = 0;\n\t      t = 2*dc;\n\t      for(var i=1; i<n8; i++) {\n\t        c -= dc;\n\t        dc += t*c;\n\t        s += ds;\n\t        ds -= t*s;\n\t        _cstb[i] = s;\n\t        _cstb[n4 - i] = c;\n\t      }\n\t      if(n8 !== 0) {\n\t        _cstb[n8] = Math.sqrt(0.5);\n\t      }\n\t      for(var j=0; j<n4; j++) {\n\t        _cstb[n2 - j]  = _cstb[j];\n\t      }\n\t      for(var k=0; k<n2p4; k++) {\n\t        _cstb[k + n2] = -_cstb[k];\n\t      }\n\t    }\n\t  };\n\t  // aliases (public APIs)\n\t  var apis = ['init', 'fft1d', 'ifft1d', 'fft2d', 'ifft2d'];\n\t  for(var i=0; i<apis.length; i++) {\n\t    FFT[apis[i]] = core[apis[i]];\n\t  }\n\t  FFT.bt = core.bt1d;\n\t  FFT.fft = core.fft1d;\n\t  FFT.ifft = core.ifft1d;\n\t  \n\t  return FFT;\n\t}).call(this);\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** ml-fft.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 9b80e1425f8a39623bf1\n **/","'use strict';\n\nexports.FFTUtils = require(\"./FFTUtils\");\nexports.FFT = require('./fftlib');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict'\n\nvar FFT = require('./fftlib');\n\nvar FFTUtils= {\n    DEBUG : false,\n\n    /**\n     * Calculates the inverse of a 2D Fourier transform\n     *\n     * @param ft\n     * @param ftRows\n     * @param ftCols\n     * @return\n     */\n    ifft2DArray : function(ft, ftRows, ftCols){\n        var tempTransform = new Array(ftRows * ftCols);\n        var nRows = ftRows / 2;\n        var nCols = (ftCols - 1) * 2;\n        // reverse transform columns\n        FFT.init(nRows);\n        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n        for (var iCol = 0; iCol < ftCols; iCol++) {\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tmpCols.re[iRow] = ft[(iRow * 2) * ftCols + iCol];\n                tmpCols.im[iRow] = ft[(iRow * 2 + 1) * ftCols + iCol];\n            }\n            //Unnormalized inverse transform\n            FFT.bt(tmpCols.re, tmpCols.im);\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tempTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n                tempTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n            }\n        }\n\n        // reverse row transform\n        var finalTransform = new Array(nRows * nCols);\n        FFT.init(nCols);\n        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n        var scale = nCols * nRows;\n        for (var iRow = 0; iRow < ftRows; iRow += 2) {\n            tmpRows.re[0] = tempTransform[iRow * ftCols];\n            tmpRows.im[0] = tempTransform[(iRow + 1) * ftCols];\n            for (var iCol = 1; iCol < ftCols; iCol++) {\n                tmpRows.re[iCol] = tempTransform[iRow * ftCols + iCol];\n                tmpRows.im[iCol] = tempTransform[(iRow + 1) * ftCols + iCol];\n                tmpRows.re[nCols - iCol] = tempTransform[iRow * ftCols + iCol];\n                tmpRows.im[nCols - iCol] = -tempTransform[(iRow + 1) * ftCols + iCol];\n            }\n            //Unnormalized inverse transform\n            FFT.bt(tmpRows.re, tmpRows.im);\n\n            var indexB = (iRow / 2) * nCols;\n            for (var iCol = nCols - 1; iCol >= 0; iCol--) {\n                finalTransform[indexB + iCol] = tmpRows.re[iCol] / scale;\n            }\n        }\n        return finalTransform;\n    },\n    /**\n     * Calculates the fourier transform of a matrix of size (nRows,nCols) It is\n     * assumed that both nRows and nCols are a power of two\n     *\n     * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the\n     * even rows contain the real part and the odd rows the imaginary part of the\n     * transform\n     * @param data\n     * @param nRows\n     * @param nCols\n     * @return\n     */\n    fft2DArray:function(data, nRows, nCols, opt) {\n        var options = Object.assign({},{inplace:true})\n        var ftCols = (nCols / 2 + 1);\n        var ftRows = nRows * 2;\n        var tempTransform = new Array(ftRows * ftCols);\n        FFT.init(nCols);\n        // transform rows\n        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n        var row1 = {re: new Array(nCols), im: new Array(nCols)}\n        var row2 = {re: new Array(nCols), im: new Array(nCols)}\n        var index, iRow0, iRow1, iRow2, iRow3;\n        for (var iRow = 0; iRow < nRows / 2; iRow++) {\n            index = (iRow * 2) * nCols;\n            tmpRows.re = data.slice(index, index + nCols);\n\n            index = (iRow * 2 + 1) * nCols;\n            tmpRows.im = data.slice(index, index + nCols);\n\n            FFT.fft1d(tmpRows.re, tmpRows.im);\n\n            this.reconstructTwoRealFFT(tmpRows, row1, row2);\n            //Now lets put back the result into the output array\n            iRow0 = (iRow * 4) * ftCols;\n            iRow1 = (iRow * 4 + 1) * ftCols;\n            iRow2 = (iRow * 4 + 2) * ftCols;\n            iRow3 = (iRow * 4 + 3) * ftCols;\n            for (var k = ftCols - 1; k >= 0; k--) {\n                tempTransform[iRow0 + k] = row1.re[k];\n                tempTransform[iRow1 + k] = row1.im[k];\n                tempTransform[iRow2 + k] = row2.re[k];\n                tempTransform[iRow3 + k] = row2.im[k];\n            }\n        }\n\n        //console.log(tempTransform);\n        row1 = null;\n        row2 = null;\n        // transform columns\n        var finalTransform = new Array(ftRows * ftCols);\n\n        FFT.init(nRows);\n        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n        for (var iCol = ftCols - 1; iCol >= 0; iCol--) {\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tmpCols.re[iRow] = tempTransform[(iRow * 2) * ftCols + iCol];\n                tmpCols.im[iRow] = tempTransform[(iRow * 2 + 1) * ftCols + iCol];\n                //TODO Chech why this happens\n                if(isNaN(tmpCols.re[iRow])){\n                    tmpCols.re[iRow]=0;\n                }\n                if(isNaN(tmpCols.im[iRow])){\n                    tmpCols.im[iRow]=0;\n                }\n            }\n            FFT.fft1d(tmpCols.re, tmpCols.im);\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                finalTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n                finalTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n            }\n        }\n\n        //console.log(finalTransform);\n        return finalTransform;\n\n    },\n    /**\n     *\n     * @param fourierTransform\n     * @param realTransform1\n     * @param realTransform2\n     *\n     * Reconstructs the individual Fourier transforms of two simultaneously\n     * transformed series. Based on the Symmetry relationships (the asterisk\n     * denotes the complex conjugate)\n     *\n     * F_{N-n} = F_n^{*} for a purely real f transformed to F\n     *\n     * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G\n     *\n     */\n    reconstructTwoRealFFT:function(fourierTransform, realTransform1, realTransform2) {\n        var length = fourierTransform.re.length;\n\n        // the components n=0 are trivial\n        realTransform1.re[0] = fourierTransform.re[0];\n        realTransform1.im[0] = 0.0;\n        realTransform2.re[0] = fourierTransform.im[0];\n        realTransform2.im[0] = 0.0;\n        var rm, rp, im, ip, j;\n        for (var i = length / 2; i > 0; i--) {\n            j = length - i;\n            rm = 0.5 * (fourierTransform.re[i] - fourierTransform.re[j]);\n            rp = 0.5 * (fourierTransform.re[i] + fourierTransform.re[j]);\n            im = 0.5 * (fourierTransform.im[i] - fourierTransform.im[j]);\n            ip = 0.5 * (fourierTransform.im[i] + fourierTransform.im[j]);\n            realTransform1.re[i] = rp;\n            realTransform1.im[i] = im;\n            realTransform1.re[j] = rp;\n            realTransform1.im[j] = -im;\n            realTransform2.re[i] = ip;\n            realTransform2.im[i] = -rm;\n            realTransform2.re[j] = ip;\n            realTransform2.im[j] = rm;\n        }\n    },\n\n    /**\n     * In place version of convolute 2D\n     *\n     * @param ftSignal\n     * @param ftFilter\n     * @param ftRows\n     * @param ftCols\n     * @return\n     */\n    convolute2DI:function(ftSignal, ftFilter, ftRows, ftCols) {\n        var re, im;\n        for (var iRow = 0; iRow < ftRows / 2; iRow++) {\n            for (var iCol = 0; iCol < ftCols; iCol++) {\n                //\n                re = ftSignal[(iRow * 2) * ftCols + iCol]\n                    * ftFilter[(iRow * 2) * ftCols + iCol]\n                    - ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n                    * ftFilter[(iRow * 2 + 1) * ftCols + iCol];\n                im = ftSignal[(iRow * 2) * ftCols + iCol]\n                    * ftFilter[(iRow * 2 + 1) * ftCols + iCol]\n                    + ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n                    * ftFilter[(iRow * 2) * ftCols + iCol];\n                //\n                ftSignal[(iRow * 2) * ftCols + iCol] = re;\n                ftSignal[(iRow * 2 + 1) * ftCols + iCol] = im;\n            }\n        }\n    },\n    /**\n     *\n     * @param data\n     * @param kernel\n     * @param nRows\n     * @param nCols\n     * @returns {*}\n     */\n    convolute:function(data, kernel, nRows, nCols, opt) {\n        var ftSpectrum = new Array(nCols * nRows);\n        for (var i = 0; i<nRows * nCols; i++) {\n            ftSpectrum[i] = data[i];\n        }\n\n        ftSpectrum = this.fft2DArray(ftSpectrum, nRows, nCols);\n\n\n        var dimR = kernel.length;\n        var dimC = kernel[0].length;\n        var ftFilterData = new Array(nCols * nRows);\n        for(var i = 0; i < nCols * nRows; i++) {\n            ftFilterData[i] = 0;\n        }\n\n        var iRow, iCol;\n        var shiftR = Math.floor((dimR - 1) / 2);\n        var shiftC = Math.floor((dimC - 1) / 2);\n        for (var ir = 0; ir < dimR; ir++) {\n            iRow = (ir - shiftR + nRows) % nRows;\n            for (var ic = 0; ic < dimC; ic++) {\n                iCol = (ic - shiftC + nCols) % nCols;\n                ftFilterData[iRow * nCols + iCol] = kernel[ir][ic];\n            }\n        }\n        ftFilterData = this.fft2DArray(ftFilterData, nRows, nCols);\n\n        var ftRows = nRows * 2;\n        var ftCols = nCols / 2 + 1;\n        this.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);\n\n        return this.ifft2DArray(ftSpectrum, ftRows, ftCols);\n    },\n\n\n    toRadix2:function(data, nRows, nCols) {\n        var i, j, irow, icol;\n        var cols = nCols, rows = nRows, prows=0, pcols=0;\n        if(!(nCols !== 0 && (nCols & (nCols - 1)) === 0)) {\n            //Then we have to make a pading to next radix2\n            cols = 0;\n            while((nCols>>++cols)!=0);\n            cols=1<<cols;\n            pcols = cols-nCols;\n        }\n        if(!(nRows !== 0 && (nRows & (nRows - 1)) === 0)) {\n            //Then we have to make a pading to next radix2\n            rows = 0;\n            while((nRows>>++rows)!=0);\n            rows=1<<rows;\n            prows = (rows-nRows)*cols;\n        }\n        if(rows==nRows&&cols==nCols)//Do nothing. Returns the same input!!! Be careful\n            return {data:data, rows:nRows, cols:nCols};\n\n        var output = new Array(rows*cols);\n        var shiftR = Math.floor((rows-nRows)/2)-nRows;\n        var shiftC = Math.floor((cols-nCols)/2)-nCols;\n\n        for( i = 0; i < rows; i++) {\n            irow = i*cols;\n            icol = ((i-shiftR) % nRows) * nCols;\n            for( j = 0; j < cols; j++) {\n                output[irow+j] = data[(icol+(j-shiftC) % nCols) ];\n            }\n        }\n        return {data:output, rows:rows, cols:cols};\n    },\n\n    /**\n     * Crop the given matrix to fit the corresponding number of rows and columns\n     */\n    crop:function(data, rows, cols, nRows, nCols, opt) {\n\n        if(rows == nRows && cols == nCols)//Do nothing. Returns the same input!!! Be careful\n            return data;\n\n        var options = Object.assign({}, opt);\n\n        var output = new Array(nCols*nRows);\n\n        var shiftR = Math.floor((rows-nRows)/2);\n        var shiftC = Math.floor((cols-nCols)/2);\n        var destinyRow, sourceRow, i, j;\n        for( i = 0; i < nRows; i++) {\n            destinyRow = i*nCols;\n            sourceRow = (i+shiftR)*cols;\n            for( j = 0;j < nCols; j++) {\n                output[destinyRow+j] = data[sourceRow+(j+shiftC)];\n            }\n        }\n\n        return output;\n    }\n}\n\nmodule.exports = FFTUtils;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/FFTUtils.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * Fast Fourier Transform module\n * 1D-FFT/IFFT, 2D-FFT/IFFT (radix-2)\n */\nvar FFT = (function(){\n  var FFT;  \n  \n  if(typeof exports !== 'undefined') {\n    FFT = exports;   // for CommonJS\n  } else {\n    FFT = {};\n  }\n  \n  var version = {\n    release: '0.3.0',\n    date: '2013-03'\n  };\n  FFT.toString = function() {\n    return \"version \" + version.release + \", released \" + version.date;\n  };\n\n  // core operations\n  var _n = 0,          // order\n      _bitrev = null,  // bit reversal table\n      _cstb = null;    // sin/cos table\n\n  var core = {\n    init : function(n) {\n      if(n !== 0 && (n & (n - 1)) === 0) {\n        _n = n;\n        core._initArray();\n        core._makeBitReversalTable();\n        core._makeCosSinTable();\n      } else {\n        throw new Error(\"init: radix-2 required\");\n      }\n    },\n    // 1D-FFT\n    fft1d : function(re, im) {\n      core.fft(re, im, 1);\n    },\n    // 1D-IFFT\n    ifft1d : function(re, im) {\n      var n = 1/_n;\n      core.fft(re, im, -1);\n      for(var i=0; i<_n; i++) {\n        re[i] *= n;\n        im[i] *= n;\n      }\n    },\n     // 1D-IFFT\n    bt1d : function(re, im) {\n      core.fft(re, im, -1);\n    },\n    // 2D-FFT Not very useful if the number of rows have to be equal to cols\n    fft2d : function(re, im) {\n      var tre = [],\n          tim = [],\n          i = 0;\n      // x-axis\n      for(var y=0; y<_n; y++) {\n        i = y*_n;\n        for(var x1=0; x1<_n; x1++) {\n          tre[x1] = re[x1 + i];\n          tim[x1] = im[x1 + i];\n        }\n        core.fft1d(tre, tim);\n        for(var x2=0; x2<_n; x2++) {\n          re[x2 + i] = tre[x2];\n          im[x2 + i] = tim[x2];\n        }\n      }\n      // y-axis\n      for(var x=0; x<_n; x++) {\n        for(var y1=0; y1<_n; y1++) {\n          i = x + y1*_n;\n          tre[y1] = re[i];\n          tim[y1] = im[i];\n        }\n        core.fft1d(tre, tim);\n        for(var y2=0; y2<_n; y2++) {\n          i = x + y2*_n;\n          re[i] = tre[y2];\n          im[i] = tim[y2];\n        }\n      }\n    },\n    // 2D-IFFT\n    ifft2d : function(re, im) {\n      var tre = [],\n          tim = [],\n          i = 0;\n      // x-axis\n      for(var y=0; y<_n; y++) {\n        i = y*_n;\n        for(var x1=0; x1<_n; x1++) {\n          tre[x1] = re[x1 + i];\n          tim[x1] = im[x1 + i];\n        }\n        core.ifft1d(tre, tim);\n        for(var x2=0; x2<_n; x2++) {\n          re[x2 + i] = tre[x2];\n          im[x2 + i] = tim[x2];\n        }\n      }\n      // y-axis\n      for(var x=0; x<_n; x++) {\n        for(var y1=0; y1<_n; y1++) {\n          i = x + y1*_n;\n          tre[y1] = re[i];\n          tim[y1] = im[i];\n        }\n        core.ifft1d(tre, tim);\n        for(var y2=0; y2<_n; y2++) {\n          i = x + y2*_n;\n          re[i] = tre[y2];\n          im[i] = tim[y2];\n        }\n      }\n    },\n    // core operation of FFT\n    fft : function(re, im, inv) {\n      var d, h, ik, m, tmp, wr, wi, xr, xi,\n          n4 = _n >> 2;\n      // bit reversal\n      for(var l=0; l<_n; l++) {\n        m = _bitrev[l];\n        if(l < m) {\n          tmp = re[l];\n          re[l] = re[m];\n          re[m] = tmp;\n          tmp = im[l];\n          im[l] = im[m];\n          im[m] = tmp;\n        }\n      }\n      // butterfly operation\n      for(var k=1; k<_n; k<<=1) {\n        h = 0;\n        d = _n/(k << 1);\n        for(var j=0; j<k; j++) {\n          wr = _cstb[h + n4];\n          wi = inv*_cstb[h];\n          for(var i=j; i<_n; i+=(k<<1)) {\n            ik = i + k;\n            xr = wr*re[ik] + wi*im[ik];\n            xi = wr*im[ik] - wi*re[ik];\n            re[ik] = re[i] - xr;\n            re[i] += xr;\n            im[ik] = im[i] - xi;\n            im[i] += xi;\n          }\n          h += d;\n        }\n      }\n    },\n    // initialize the array (supports TypedArray)\n    _initArray : function() {\n      if(typeof Uint32Array !== 'undefined') {\n        _bitrev = new Uint32Array(_n);\n      } else {\n        _bitrev = [];\n      }\n      if(typeof Float64Array !== 'undefined') {\n        _cstb = new Float64Array(_n*1.25);\n      } else {\n        _cstb = [];\n      }\n    },\n    // zero padding\n    _paddingZero : function() {\n      // TODO\n    },\n    // makes bit reversal table\n    _makeBitReversalTable : function() {\n      var i = 0,\n          j = 0,\n          k = 0;\n      _bitrev[0] = 0;\n      while(++i < _n) {\n        k = _n >> 1;\n        while(k <= j) {\n          j -= k;\n          k >>= 1;\n        }\n        j += k;\n        _bitrev[i] = j;\n      }\n    },\n    // makes trigonometiric function table\n    _makeCosSinTable : function() {\n      var n2 = _n >> 1,\n          n4 = _n >> 2,\n          n8 = _n >> 3,\n          n2p4 = n2 + n4,\n          t = Math.sin(Math.PI/_n),\n          dc = 2*t*t,\n          ds = Math.sqrt(dc*(2 - dc)),\n          c = _cstb[n4] = 1,\n          s = _cstb[0] = 0;\n      t = 2*dc;\n      for(var i=1; i<n8; i++) {\n        c -= dc;\n        dc += t*c;\n        s += ds;\n        ds -= t*s;\n        _cstb[i] = s;\n        _cstb[n4 - i] = c;\n      }\n      if(n8 !== 0) {\n        _cstb[n8] = Math.sqrt(0.5);\n      }\n      for(var j=0; j<n4; j++) {\n        _cstb[n2 - j]  = _cstb[j];\n      }\n      for(var k=0; k<n2p4; k++) {\n        _cstb[k + n2] = -_cstb[k];\n      }\n    }\n  };\n  // aliases (public APIs)\n  var apis = ['init', 'fft1d', 'ifft1d', 'fft2d', 'ifft2d'];\n  for(var i=0; i<apis.length; i++) {\n    FFT[apis[i]] = core[apis[i]];\n  }\n  FFT.bt = core.bt1d;\n  FFT.fft = core.fft1d;\n  FFT.ifft = core.ifft1d;\n  \n  return FFT;\n}).call(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/fftlib.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}