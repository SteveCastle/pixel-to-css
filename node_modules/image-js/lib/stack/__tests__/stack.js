"use strict";

var _common = require("test/common");

describe('Core methods of Stack objects', function () {
  let stack = new _common.Stack([(0, _common.getSquare)(), (0, _common.getSquare)()]);
  it('Stack.load', async () => {
    const images = await _common.Stack.load([(0, _common.getImage)('BW2x2.png'), (0, _common.getImage)('BW3x3.png')]);
    expect(images).toHaveLength(2);
    expect(images).toBeInstanceOf(_common.Stack);
    expect(images[0]).toBeInstanceOf(_common.Image);
    expect(images[1]).toBeInstanceOf(_common.Image);
    expect(images[0].width).toBe(2);
    expect(images[1].width).toBe(3);
  });
  it('Stack.load with error', async () => {
    await expect(_common.Stack.load([(0, _common.getImage)('BW2x2.png'), (0, _common.getImage)('inexistant')])).rejects.toThrow(/ENOENT/);
  });
  it('should be an Array', function () {
    expect(stack).toBeInstanceOf(_common.Stack);
    expect(stack).toBeInstanceOf(Array);
    expect(Array.isArray(stack)).toBe(true);
  });
  it('should have Array methods on prototype', function () {
    stack.forEach(function (image) {
      expect(image).toBeInstanceOf(_common.Image);
    });
    expect(stack.filter(() => false)).toHaveLength(0);
  });
  it('map should return a Stack', function () {
    let result = stack.map(function (image) {
      return image.grey();
    });
    expect(result).toBeInstanceOf(_common.Stack);
    expect(result).toHaveLength(2);
    expect(result[0].components).toBe(1);
    expect(function () {
      stack.map();
    }).toThrow(TypeError);
  });
});