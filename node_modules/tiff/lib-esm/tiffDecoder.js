import { IOBuffer } from 'iobuffer';
import { applyHorizontalDifferencing, applyHorizontalDifferencingColor, } from './horizontalDifferencing';
import IFD from './ifd';
import { getByteLength, readData } from './ifdValue';
import { decompressLzw } from './lzw';
import TiffIfd from './tiffIfd';
const defaultOptions = {
    ignoreImageData: false,
    onlyFirst: false,
};
export default class TIFFDecoder extends IOBuffer {
    constructor(data) {
        super(data);
        this._nextIFD = 0;
    }
    get isMultiPage() {
        let c = 0;
        this.decodeHeader();
        while (this._nextIFD) {
            c++;
            this.decodeIFD({ ignoreImageData: true }, true);
            if (c === 2) {
                return true;
            }
        }
        if (c === 1) {
            return false;
        }
        throw unsupported('ifdCount', c);
    }
    get pageCount() {
        let c = 0;
        this.decodeHeader();
        while (this._nextIFD) {
            c++;
            this.decodeIFD({ ignoreImageData: true }, true);
        }
        if (c > 0) {
            return c;
        }
        throw unsupported('ifdCount', c);
    }
    decode(options = {}) {
        options = Object.assign({}, defaultOptions, options);
        const result = [];
        this.decodeHeader();
        while (this._nextIFD) {
            result.push(this.decodeIFD(options, true));
            if (options.onlyFirst) {
                return [result[0]];
            }
        }
        return result;
    }
    decodeHeader() {
        // Byte offset
        const value = this.readUint16();
        if (value === 0x4949) {
            this.setLittleEndian();
        }
        else if (value === 0x4d4d) {
            this.setBigEndian();
        }
        else {
            throw new Error(`invalid byte order: 0x${value.toString(16)}`);
        }
        // Magic number
        if (this.readUint16() !== 42) {
            throw new Error('not a TIFF file');
        }
        // Offset of the first IFD
        this._nextIFD = this.readUint32();
    }
    decodeIFD(options, tiff) {
        this.seek(this._nextIFD);
        let ifd;
        if (tiff) {
            ifd = new TiffIfd();
        }
        else {
            if (!options.kind) {
                throw new Error(`kind is missing`);
            }
            ifd = new IFD(options.kind);
        }
        const numEntries = this.readUint16();
        for (let i = 0; i < numEntries; i++) {
            this.decodeIFDEntry(ifd);
        }
        if (!options.ignoreImageData) {
            if (!(ifd instanceof TiffIfd)) {
                throw new Error('must be a tiff ifd');
            }
            this.decodeImageData(ifd);
        }
        this._nextIFD = this.readUint32();
        return ifd;
    }
    decodeIFDEntry(ifd) {
        const offset = this.offset;
        const tag = this.readUint16();
        const type = this.readUint16();
        const numValues = this.readUint32();
        if (type < 1 || type > 12) {
            this.skip(4); // unknown type, skip this value
            return;
        }
        const valueByteLength = getByteLength(type, numValues);
        if (valueByteLength > 4) {
            this.seek(this.readUint32());
        }
        const value = readData(this, type, numValues);
        ifd.fields.set(tag, value);
        // Read sub-IFDs
        if (tag === 0x8769 || tag === 0x8825) {
            let currentOffset = this.offset;
            let kind = 'exif';
            if (tag === 0x8769) {
                kind = 'exif';
            }
            else if (tag === 0x8825) {
                kind = 'gps';
            }
            this._nextIFD = value;
            ifd[kind] = this.decodeIFD({
                kind,
                ignoreImageData: true,
            }, false);
            this.offset = currentOffset;
        }
        // go to the next entry
        this.seek(offset);
        this.skip(12);
    }
    decodeImageData(ifd) {
        const orientation = ifd.orientation;
        if (orientation && orientation !== 1) {
            throw unsupported('orientation', orientation);
        }
        switch (ifd.type) {
            case 0: // WhiteIsZero
            case 1: // BlackIsZero
            case 2: // RGB
            case 3: // Palette color
                this.readStripData(ifd);
                break;
            default:
                throw unsupported('image type', ifd.type);
        }
        this.applyPredictor(ifd);
        if (ifd.type === 0) {
            // WhiteIsZero: we invert the values
            const bitDepth = ifd.bitsPerSample;
            const maxValue = Math.pow(2, bitDepth) - 1;
            for (let i = 0; i < ifd.data.length; i++) {
                ifd.data[i] = maxValue - ifd.data[i];
            }
        }
    }
    readStripData(ifd) {
        const width = ifd.width;
        const height = ifd.height;
        const bitDepth = ifd.bitsPerSample;
        const sampleFormat = ifd.sampleFormat;
        const size = width * height * ifd.samplesPerPixel;
        const data = getDataArray(size, bitDepth, sampleFormat);
        const rowsPerStrip = ifd.rowsPerStrip;
        const maxPixels = rowsPerStrip * width * ifd.samplesPerPixel;
        const stripOffsets = ifd.stripOffsets;
        const stripByteCounts = ifd.stripByteCounts;
        let remainingPixels = size;
        let pixel = 0;
        for (let i = 0; i < stripOffsets.length; i++) {
            let stripData = new DataView(this.buffer, stripOffsets[i], stripByteCounts[i]);
            // Last strip can be smaller
            let length = remainingPixels > maxPixels ? maxPixels : remainingPixels;
            remainingPixels -= length;
            let dataToFill = stripData;
            switch (ifd.compression) {
                case 1: {
                    // No compression, nothing to do
                    break;
                }
                case 5: {
                    // LZW compression
                    dataToFill = decompressLzw(stripData);
                    break;
                }
                case 2: // CCITT Group 3 1-Dimensional Modified Huffman run length encoding
                    throw unsupported('Compression', 'CCITT Group 3');
                case 32773: // PackBits compression
                    throw unsupported('Compression', 'PackBits');
                default:
                    throw new Error(`invalid compression: ${ifd.compression}`);
            }
            pixel = this.fillUncompressed(bitDepth, sampleFormat, data, dataToFill, pixel, length);
        }
        ifd.data = data;
    }
    fillUncompressed(bitDepth, sampleFormat, data, stripData, pixel, length) {
        if (bitDepth === 8) {
            return fill8bit(data, stripData, pixel, length);
        }
        else if (bitDepth === 16) {
            return fill16bit(data, stripData, pixel, length, this.isLittleEndian());
        }
        else if (bitDepth === 32 && sampleFormat === 3) {
            return fillFloat32(data, stripData, pixel, length, this.isLittleEndian());
        }
        else {
            throw unsupported('bitDepth', bitDepth);
        }
    }
    applyPredictor(ifd) {
        const bitDepth = ifd.bitsPerSample;
        switch (ifd.predictor) {
            case 1: {
                // No prediction scheme, nothing to do
                break;
            }
            case 2: {
                if (bitDepth === 8) {
                    if (ifd.samplesPerPixel === 1) {
                        applyHorizontalDifferencing(ifd.data, ifd.width);
                    }
                    else if (ifd.samplesPerPixel === 3) {
                        applyHorizontalDifferencingColor(ifd.data, ifd.width);
                    }
                    else {
                        throw new Error('Horizontal differencing is only supported for images with 1 or 3 samples per pixel');
                    }
                }
                else {
                    throw new Error('Horizontal differencing is only supported for 8-bit images');
                }
                break;
            }
            default:
                throw new Error(`invalid predictor: ${ifd.predictor}`);
        }
    }
}
function getDataArray(size, bitDepth, sampleFormat) {
    if (bitDepth === 8) {
        return new Uint8Array(size);
    }
    else if (bitDepth === 16) {
        return new Uint16Array(size);
    }
    else if (bitDepth === 32 && sampleFormat === 3) {
        return new Float32Array(size);
    }
    else {
        throw unsupported('bit depth / sample format', `${bitDepth} / ${sampleFormat}`);
    }
}
function fill8bit(dataTo, dataFrom, index, length) {
    for (let i = 0; i < length; i++) {
        dataTo[index++] = dataFrom.getUint8(i);
    }
    return index;
}
function fill16bit(dataTo, dataFrom, index, length, littleEndian) {
    for (let i = 0; i < length * 2; i += 2) {
        dataTo[index++] = dataFrom.getUint16(i, littleEndian);
    }
    return index;
}
function fillFloat32(dataTo, dataFrom, index, length, littleEndian) {
    for (let i = 0; i < length * 4; i += 4) {
        dataTo[index++] = dataFrom.getFloat32(i, littleEndian);
    }
    return index;
}
function unsupported(type, value) {
    return new Error(`Unsupported ${type}: ${value}`);
}
//# sourceMappingURL=tiffDecoder.js.map